<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mnncorrect: mnncorrect Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mnncorrect
   </div>
   <div id="projectbrief">Batch correction with mutual nearest neighbors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mnncorrect Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Batch correction with mutual nearest neighbors.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmnncorrect_1_1Details.html">Details</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correction details from <code><a class="el" href="#af743bee735cf1cf3c1b018065b64eeed">compute()</a></code>.  <a href="structmnncorrect_1_1Details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmnncorrect_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmnncorrect_1_1Options.html" title="Options for compute().">Options</a> for <code><a class="el" href="#af743bee735cf1cf3c1b018065b64eeed">compute()</a></code>.  <a href="structmnncorrect_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a628f306b43e4b2a96382aa7025940694" id="r_a628f306b43e4b2a96382aa7025940694"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a628f306b43e4b2a96382aa7025940694">ReferencePolicy</a> : char { <b>INPUT</b>
, <b>MAX_SIZE</b>
, <b>MAX_VARIANCE</b>
, <b>MAX_RSS</b>
 }</td></tr>
<tr class="separator:a628f306b43e4b2a96382aa7025940694"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af743bee735cf1cf3c1b018065b64eeed" id="r_af743bee735cf1cf3c1b018065b64eeed"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Float_ , typename Matrix_ &gt; </td></tr>
<tr class="memitem:af743bee735cf1cf3c1b018065b64eeed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmnncorrect_1_1Details.html">Details</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af743bee735cf1cf3c1b018065b64eeed">compute</a> (size_t num_dim, const std::vector&lt; size_t &gt; &amp;num_obs, const std::vector&lt; const Float_ * &gt; &amp;batches, Float_ *output, const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:af743bee735cf1cf3c1b018065b64eeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c46a6844c6c96605bad71e598a81cb0" id="r_a8c46a6844c6c96605bad71e598a81cb0"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Float_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:a8c46a6844c6c96605bad71e598a81cb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmnncorrect_1_1Details.html">Details</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c46a6844c6c96605bad71e598a81cb0">compute</a> (size_t num_dim, const std::vector&lt; size_t &gt; &amp;num_obs, const Float_ *input, Float_ *output, const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:a8c46a6844c6c96605bad71e598a81cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f22063bbb9f2daccb3704f41a7471" id="r_a141f22063bbb9f2daccb3704f41a7471"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Float_ , typename Batch_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:a141f22063bbb9f2daccb3704f41a7471"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmnncorrect_1_1Details.html">Details</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a141f22063bbb9f2daccb3704f41a7471">compute</a> (size_t num_dim, size_t num_obs, const Float_ *input, const Batch_ *batch, Float_ *output, const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:a141f22063bbb9f2daccb3704f41a7471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b556e96c8995a0dba23e412b75c838a" id="r_a1b556e96c8995a0dba23e412b75c838a"><td class="memTemplParams" colspan="2">template&lt;typename Task_ , class Run_ &gt; </td></tr>
<tr class="memitem:a1b556e96c8995a0dba23e412b75c838a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b556e96c8995a0dba23e412b75c838a">parallelize</a> (int num_workers, Task_ num_tasks, Run_ run_task_range)</td></tr>
<tr class="separator:a1b556e96c8995a0dba23e412b75c838a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Batch correction with mutual nearest neighbors. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a628f306b43e4b2a96382aa7025940694" name="a628f306b43e4b2a96382aa7025940694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628f306b43e4b2a96382aa7025940694">&#9670;&#160;</a></span>ReferencePolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a628f306b43e4b2a96382aa7025940694">mnncorrect::ReferencePolicy</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Policy for choosing the first reference batch with the automatic merging procedure.</p>
<ul>
<li><code>INPUT</code> will use the first supplied batch in the input order. This is useful in cases where one batch is known to contain most subpopulations and should be used as the reference, but there is no obvious ordering for the other batches.</li>
<li><code>MAX_SIZE</code> will use the largest batch (i.e., with the most observations). This is simple to compute and was the previous default; it does, at least, ensure that the initial reference has enough cells for stable correction.</li>
<li><code>MAX_VARIANCE</code> will use the batch with the greatest variance. This improves the likelihood of obtaining an reference that contains a diversity of subpopulations and thus is more likely to form sensible MNN pairs with subsequent batches.</li>
<li><code>MAX_RSS</code> will use the batch with the greatest residual sum of squares (RSS). This is similar to <code>MAX_VARIANCE</code> but it puts more weight on batches with more cells, so as to avoid picking small batches with few cells and unstable population strcuture. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8c46a6844c6c96605bad71e598a81cb0" name="a8c46a6844c6c96605bad71e598a81cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c46a6844c6c96605bad71e598a81cb0">&#9670;&#160;</a></span>compute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Float_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmnncorrect_1_1Details.html">Details</a> mnncorrect::compute </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>num_obs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience overload to merge contiguous batches contained in the same array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index of the neighbor search. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the distances in the neighbor search. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data matrix. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Vector of length equal to the number of batches. The <code>i</code>-th entry contains the number of observations in batch <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a column-major matrix of uncorrected values from all batches. The number of rows is equal to <code>num_dim</code> and the number of columns is equal to the sum of <code>num_obs</code>. The first <code>num_obs[0]</code> columns contain the uncorrected data for the first batch, the next <code>num_obs[1]</code> columns contain observations for the second batch, and so on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array containing a column-major matrix of the same dimensions as that in <code>input</code>, where the corrected values for all batches are stored. On output, the first <code>num_obs[0]</code> columns contain the corrected values of the first batch, the second <code>num_obs[1]</code> columns contain the corrected values of the second batch, and so on. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Statistics about the merge process. </dd></dl>

</div>
</div>
<a id="af743bee735cf1cf3c1b018065b64eeed" name="af743bee735cf1cf3c1b018065b64eeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af743bee735cf1cf3c1b018065b64eeed">&#9670;&#160;</a></span>compute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Float_ , typename Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmnncorrect_1_1Details.html">Details</a> mnncorrect::compute </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>num_obs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Float_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>batches</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Batch correction using mutual nearest neighbors.</p>
<p>This function implements a variant of the MNN correction method described by Haghverdi <em>et al.</em> (2018). Two cells from different batches can form an MNN pair if they each belong in each other's set of nearest neighbors. The MNN pairs are assumed to represent cells from corresponding subpopulations across the two batches. Any differences in location between the paired cells can be interpreted as the batch effect and targeted for removal.</p>
<p>We consider one batch to be the "reference" and the other to be the "target", where the aim is to correct the latter to the (unchanged) former. For each observation in the target batch, we find the closest MNN pairs (based on the locations of the paired observation in the same batch) and we compute a robust average of the correction vectors involving those pairs. This average is used to obtain a single correction vector that is applied to the target observation to obtain corrected values.</p>
<p>Each MNN pair's correction vector is computed between the "center of mass" locations for the paired observations. The center of mass for each observation is defined as a robust average of a subset of neighboring observations from the same batch. Robustification is performed by iterations of trimming of observations that are furthest from the mean. In addition, we explicitly remove observations that are more than a certain distance from the observation in the MNN pair.</p>
<dl class="section see"><dt>See also</dt><dd>Haghverdi L et al. (2018). Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors. <em>Nature Biotech.</em> 36, 421-427</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index of the neighbor search. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the distances in the neighbor search. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data matrix. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Vector of length equal to the number of batches. The <code>i</code>-th entry contains the number of observations in batch <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>Vector of length equal to the number of batches. The <code>i</code>-th entry points to a column-major dimension-by-observation array containing the uncorrected data for batch <code>i</code>, where the number of rows is equal to <code>num_dim</code> and the number of columns is equal to <code>num_obs[i]</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array containing a column-major matrix with number of rows equal to <code>num_dim</code> and number of columns equal to the sum of <code>num_obs</code>. On output, the first <code>num_obs[0]</code> columns contain the corrected values of the first batch, the second <code>num_obs[1]</code> columns contain the corrected values of the second batch, and so on. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Statistics about the merge process. </dd></dl>

</div>
</div>
<a id="a141f22063bbb9f2daccb3704f41a7471" name="a141f22063bbb9f2daccb3704f41a7471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141f22063bbb9f2daccb3704f41a7471">&#9670;&#160;</a></span>compute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Float_ , typename Batch_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmnncorrect_1_1Details.html">Details</a> mnncorrect::compute </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_obs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Batch_ *</td>          <td class="paramname"><span class="paramname"><em>batch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge batches where observations are arbitrarily ordered in the same array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index of the neighbor search. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the distances in the neighbor search. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data matrix. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface. </td></tr>
    <tr><td class="paramname">Batch_</td><td>Integer type for the batch IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Number of observations across all batches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a column-major matrix of uncorrected values from all batches. The number of rows is equal to <code>num_dim</code> and the number of columns is equal to <code>num_obs</code>. Observations from the same batch do not need to be stored in adjacent columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch</td><td>Pointer to an array of length <code>num_obs</code> containing the batch identity for each observation. IDs should be zero-indexed and lie within \([0, N)\) where \(N\) is the number of unique batches. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array containing a column-major matrix of the same dimensions as that in <code>input</code>, where the corrected values for all batches are stored. The order of observations in <code>output</code> is the same as that in the <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Statistics about the merge process. </dd></dl>

</div>
</div>
<a id="a1b556e96c8995a0dba23e412b75c838a" name="a1b556e96c8995a0dba23e412b75c838a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b556e96c8995a0dba23e412b75c838a">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_ , class Run_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mnncorrect::parallelize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_workers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_</td>          <td class="paramname"><span class="paramname"><em>num_tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Run_</td>          <td class="paramname"><span class="paramname"><em>run_task_range</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_</td><td>Integer type for the number of tasks. </td></tr>
    <tr><td class="paramname">Run_</td><td>Function to execute a range of tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_workers</td><td>Number of workers. </td></tr>
    <tr><td class="paramname">num_tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">run_task_range</td><td>Function to iterate over a range of tasks within a worker.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, this is an alias to <code>subpar::parallelize_range()</code>. However, if the <code>MNNCORRECT_CUSTOM_PARALLEL</code> function-like macro is defined, it is called instead. Any user-defined macro should accept the same arguments as <code>subpar::parallelize_range()</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
