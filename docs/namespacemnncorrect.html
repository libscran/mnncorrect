<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mnncorrect: mnncorrect Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mnncorrect
   </div>
   <div id="projectbrief">Batch correction with mutual nearest neighbors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mnncorrect Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Batch correction with mutual nearest neighbors.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmnncorrect_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmnncorrect_1_1Options.html" title="Options for compute().">Options</a> for <code><a class="el" href="#a0ce88c6787f0f2ec73101fc234589ee6">compute()</a></code>.  <a href="structmnncorrect_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a67ab090aec935cd48ad2e5d3383926f7" id="r_a67ab090aec935cd48ad2e5d3383926f7"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ab090aec935cd48ad2e5d3383926f7">BatchIndex</a></td></tr>
<tr class="separator:a67ab090aec935cd48ad2e5d3383926f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5a9c9f9569fcad76a5e735cd8fae0197" id="r_a5a9c9f9569fcad76a5e735cd8fae0197"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a9c9f9569fcad76a5e735cd8fae0197">MergePolicy</a> : char { <b>INPUT</b>
, <b>SIZE</b>
, <b>VARIANCE</b>
, <b>RSS</b>
 }</td></tr>
<tr class="separator:a5a9c9f9569fcad76a5e735cd8fae0197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b556e96c8995a0dba23e412b75c838a" id="r_a1b556e96c8995a0dba23e412b75c838a"><td class="memTemplParams" colspan="2">template&lt;typename Task_ , class Run_ &gt; </td></tr>
<tr class="memitem:a1b556e96c8995a0dba23e412b75c838a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b556e96c8995a0dba23e412b75c838a">parallelize</a> (int num_workers, Task_ num_tasks, Run_ run_task_range)</td></tr>
<tr class="separator:a1b556e96c8995a0dba23e412b75c838a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce88c6787f0f2ec73101fc234589ee6" id="r_a0ce88c6787f0f2ec73101fc234589ee6"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Float_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:a0ce88c6787f0f2ec73101fc234589ee6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ce88c6787f0f2ec73101fc234589ee6">compute</a> (std::size_t num_dim, const std::vector&lt; Index_ &gt; &amp;num_obs, const std::vector&lt; const Float_ * &gt; &amp;batches, Float_ *output, const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:a0ce88c6787f0f2ec73101fc234589ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1ac3e8b237d6402465f21cb5b62f20" id="r_aaa1ac3e8b237d6402465f21cb5b62f20"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Float_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:aaa1ac3e8b237d6402465f21cb5b62f20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa1ac3e8b237d6402465f21cb5b62f20">compute</a> (std::size_t num_dim, const std::vector&lt; Index_ &gt; &amp;num_obs, const Float_ *input, Float_ *output, const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:aaa1ac3e8b237d6402465f21cb5b62f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9c4838402953d68aec1596983d01ee" id="r_aee9c4838402953d68aec1596983d01ee"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Float_ , typename Batch_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:aee9c4838402953d68aec1596983d01ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aee9c4838402953d68aec1596983d01ee">compute</a> (std::size_t num_dim, Index_ num_obs, const Float_ *input, const Batch_ *batch, Float_ *output, const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:aee9c4838402953d68aec1596983d01ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Batch correction with mutual nearest neighbors. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a67ab090aec935cd48ad2e5d3383926f7" name="a67ab090aec935cd48ad2e5d3383926f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ab090aec935cd48ad2e5d3383926f7">&#9670;&#160;</a></span>BatchIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="#a67ab090aec935cd48ad2e5d3383926f7">mnncorrect::BatchIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer type of the batch indices. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5a9c9f9569fcad76a5e735cd8fae0197" name="a5a9c9f9569fcad76a5e735cd8fae0197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9c9f9569fcad76a5e735cd8fae0197">&#9670;&#160;</a></span>MergePolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a5a9c9f9569fcad76a5e735cd8fae0197">mnncorrect::MergePolicy</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Policy for choosing the order of batches to merge.</p>
<ul>
<li><code>INPUT</code> will use the input order of the batches. Observations in the last batch are corrected first, and then the second-last batch, and so on. This allows users to control the merge order by simply changing the inputs.</li>
<li><code>SIZE</code> will merge batches in order of increasing size (i.e., the number of observations). So, the smallest batch is corrected first while the largest batch is unchanged. The aim is to lower compute time by reducing the number of observations that need to be reprocessed in later merge steps.</li>
<li><code>VARIANCE</code> will merge batches in order of increasing variance between observations. So, the batch with the lowest variance is corrected first while the batch with the highest variance is unchanged. The aim is to lower compute time by encouraging more observations to be corrected to the most variable batch, thus avoid reprocessing in later merge steps.</li>
<li><code>RSS</code> will merge batches in order of increasing residual sum of squares (RSS). This is effectively a compromise between <code>VARIANCE</code> and <code>SIZE</code>. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa1ac3e8b237d6402465f21cb5b62f20" name="aaa1ac3e8b237d6402465f21cb5b62f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1ac3e8b237d6402465f21cb5b62f20">&#9670;&#160;</a></span>compute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Float_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mnncorrect::compute </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>num_obs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience overload to merge contiguous batches contained in the same array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the input/output data. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data matrix for the neighbor search. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface. Alternatively, it may be a <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1SimpleMatrix.html">knncolle::SimpleMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Vector of length equal to the number of batches. The <code>i</code>-th entry contains the number of observations in batch <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a column-major matrix of uncorrected values from all batches. The number of rows is equal to <code>num_dim</code> and the number of columns is equal to the sum of <code>num_obs</code>. The first <code>num_obs[0]</code> columns contain the uncorrected data for the first batch, the next <code>num_obs[1]</code> columns contain observations for the second batch, and so on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array containing a column-major matrix of the same dimensions as that in <code>input</code>, where the corrected values for all batches are stored. On output, the first <code>num_obs[0]</code> columns contain the corrected values of the first batch, the second <code>num_obs[1]</code> columns contain the corrected values of the second batch, and so on. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce88c6787f0f2ec73101fc234589ee6" name="a0ce88c6787f0f2ec73101fc234589ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce88c6787f0f2ec73101fc234589ee6">&#9670;&#160;</a></span>compute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Float_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mnncorrect::compute </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>num_obs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Float_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>batches</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements a variant of the mutual nearest neighbors (MNN) method for batch correction (Haghverdi <em>et al.</em>, 2018). Two cells from different batches can form an MNN pair if they each belong in each other's set of nearest neighbors. The MNN pairs are assumed to represent cells from corresponding subpopulations across the two batches. Any differences in location between the paired cells represents an estimate of the batch effect in that part of the high-dimensional space.</p>
<p>We consider one batch to be the "reference" and the other to be the "target", where the aim is to correct the latter to the (unchanged) former. For each Each MNN pair is used to define a correction vector For each observation in the target batch, we find the closest MNN pairs (based on the locations of the paired observation in the same batch) and we compute a robust average of the correction vectors involving those pairs. This average is used to obtain a single correction vector that is applied to the target observation to obtain corrected values.</p>
<p>Each MNN pair's correction vector is computed between the "center of mass" locations for the paired observations. The center of mass for each observation is defined by recursively searching the neighbors of each MNN-involved observation (and then the neighbors of those neighbors, up to a recursion depth of <code><a class="el" href="structmnncorrect_1_1Options.html#a2ec5fc17723c0c92611c942a77b1f83f">Options::num_steps</a></code>) and computing the mean of their coordinates. This improves the correction by mitigating the "kissing effect", i.e., where the correction vectors only form between the surfaces of the mass of points in each batch.</p>
<dl class="section see"><dt>See also</dt><dd>Haghverdi L et al. (2018). Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors. <em>Nature Biotech.</em> 36, 421-427</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the input/output data. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data matrix for the neighbor search. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface. Alternatively, it may be a <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1SimpleMatrix.html">knncolle::SimpleMatrix</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Vector of length equal to the number of batches. The <code>i</code>-th entry contains the number of observations in batch <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>Vector of length equal to the number of batches. The <code>i</code>-th entry points to a column-major dimension-by-observation array containing the uncorrected data for batch <code>i</code>, where the number of rows is equal to <code>num_dim</code> and the number of columns is equal to <code>num_obs[i]</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array containing a column-major matrix with number of rows equal to <code>num_dim</code> and number of columns equal to the sum of <code>num_obs</code>. On output, the first <code>num_obs[0]</code> columns contain the corrected values of the first batch, the second <code>num_obs[1]</code> columns contain the corrected values of the second batch, and so on. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee9c4838402953d68aec1596983d01ee" name="aee9c4838402953d68aec1596983d01ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9c4838402953d68aec1596983d01ee">&#9670;&#160;</a></span>compute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Float_ , typename Batch_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mnncorrect::compute </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>num_obs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float_ *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Batch_ *</td>          <td class="paramname"><span class="paramname"><em>batch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmnncorrect_1_1Options.html">Options</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge batches where observations are arbitrarily ordered in the same array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation index. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the input/output data. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data matrix for the neighbor search. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface. Alternatively, it may be a <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1SimpleMatrix.html">knncolle::SimpleMatrix</a></code>. </td></tr>
    <tr><td class="paramname">Batch_</td><td>Integer type for the batch IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num_dim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_obs</td><td>Number of observations across all batches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array containing a column-major matrix of uncorrected values from all batches. The number of rows is equal to <code>num_dim</code> and the number of columns is equal to <code>num_obs</code>. Observations from the same batch do not need to be stored in adjacent columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch</td><td>Pointer to an array of length <code>num_obs</code> containing the batch identity for each observation. IDs should be zero-indexed and lie within \([0, N)\) where \(N\) is the number of unique batches. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array containing a column-major matrix of the same dimensions as that in <code>input</code>, where the corrected values for all batches are stored. The order of observations in <code>output</code> is the same as that in the <code>input</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b556e96c8995a0dba23e412b75c838a" name="a1b556e96c8995a0dba23e412b75c838a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b556e96c8995a0dba23e412b75c838a">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_ , class Run_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mnncorrect::parallelize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_workers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_</td>          <td class="paramname"><span class="paramname"><em>num_tasks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Run_</td>          <td class="paramname"><span class="paramname"><em>run_task_range</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_</td><td>Integer type for the number of tasks. </td></tr>
    <tr><td class="paramname">Run_</td><td>Function to execute a range of tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_workers</td><td>Number of workers. </td></tr>
    <tr><td class="paramname">num_tasks</td><td>Number of tasks. </td></tr>
    <tr><td class="paramname">run_task_range</td><td>Function to iterate over a range of tasks within a worker.</td></tr>
  </table>
  </dd>
</dl>
<p>By default, this is an alias to <code>subpar::parallelize_range()</code>. However, if the <code>MNNCORRECT_CUSTOM_PARALLEL</code> function-like macro is defined, it is called instead. Any user-defined macro should accept the same arguments as <code>subpar::parallelize_range()</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
