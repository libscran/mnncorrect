<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mnncorrect: mnncorrect::MnnCorrect&lt; Index, Float &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mnncorrect
   </div>
   <div id="projectbrief">A C++ library for MNN batch correction</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mnncorrect</b></li><li class="navelem"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmnncorrect_1_1MnnCorrect-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mnncorrect::MnnCorrect&lt; Index, Float &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Batch correction using mutual nearest neighbors.  
 <a href="classmnncorrect_1_1MnnCorrect.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MnnCorrect_8hpp_source.html">MnnCorrect.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html">Details</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correction details.  <a href="structmnncorrect_1_1MnnCorrect_1_1Details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f1bb13e1d3b24607fa5d40763d1533c" id="r_a9f1bb13e1d3b24607fa5d40763d1533c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a9f1bb13e1d3b24607fa5d40763d1533c">set_num_neighbors</a> (int n=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a1ef386edadff91de8bf5a76590012b62">Defaults::num_neighbors</a>)</td></tr>
<tr class="separator:a9f1bb13e1d3b24607fa5d40763d1533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718ef3445e338d9a4694f06069cdbcf5" id="r_a718ef3445e338d9a4694f06069cdbcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a718ef3445e338d9a4694f06069cdbcf5">set_num_mads</a> (Float n=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a8638f5341f05f82e311284c6d3272e97">Defaults::num_mads</a>)</td></tr>
<tr class="separator:a718ef3445e338d9a4694f06069cdbcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac16720074016f87dce57e6e02d6783" id="r_abac16720074016f87dce57e6e02d6783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#abac16720074016f87dce57e6e02d6783">set_approximate</a> (bool a=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#af5ce8974cee505b0bee5508a949cffba">Defaults::approximate</a>)</td></tr>
<tr class="separator:abac16720074016f87dce57e6e02d6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccae2e465b96ba5479e7413091b216b" id="r_abccae2e465b96ba5479e7413091b216b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#abccae2e465b96ba5479e7413091b216b">set_automatic_order</a> (bool a=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#aa3085207c438ba9757a792254ff1b19d">Defaults::automatic_order</a>)</td></tr>
<tr class="separator:abccae2e465b96ba5479e7413091b216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57469c9dfa55405b48d95adaadc08b5f" id="r_a57469c9dfa55405b48d95adaadc08b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a57469c9dfa55405b48d95adaadc08b5f">set_reference_policy</a> (<a class="el" href="ReferencePolicy_8hpp.html#ad6c4a54a9f9a0db1d5863fc99fb6af47">ReferencePolicy</a> r=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#afd120f73180d0caa12be40c6cb228841">Defaults::reference_policy</a>)</td></tr>
<tr class="separator:a57469c9dfa55405b48d95adaadc08b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06edf42b962df693d51ef5d986141735" id="r_a06edf42b962df693d51ef5d986141735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a06edf42b962df693d51ef5d986141735">set_robust_iterations</a> (int i=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a4ee36aa3844aa13ec6f627e80899fedc">Defaults::robust_iterations</a>)</td></tr>
<tr class="separator:a06edf42b962df693d51ef5d986141735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866645cfd68a249ad550f73f7b87b67d" id="r_a866645cfd68a249ad550f73f7b87b67d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a866645cfd68a249ad550f73f7b87b67d">set_robust_trim</a> (double t=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#ac776c7e34a88f4cef47c6ce53c936fba">Defaults::robust_trim</a>)</td></tr>
<tr class="separator:a866645cfd68a249ad550f73f7b87b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af325d93c5f76c448d3cb79622aa558d3" id="r_af325d93c5f76c448d3cb79622aa558d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#af325d93c5f76c448d3cb79622aa558d3">set_mass_cap</a> (size_t c=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a179d9c58273e3cce896b88b3e3bb78a6">Defaults::mass_cap</a>)</td></tr>
<tr class="separator:af325d93c5f76c448d3cb79622aa558d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ca84f936ea36ca7a47cfe73530be87" id="r_a94ca84f936ea36ca7a47cfe73530be87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a94ca84f936ea36ca7a47cfe73530be87">set_num_threads</a> (int n=<a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#ae065e7d42f366755d4efc2b6d34b0a84">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a94ca84f936ea36ca7a47cfe73530be87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89af13dc9d3016788abf70de9b707f70" id="r_a89af13dc9d3016788abf70de9b707f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html">Details</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a89af13dc9d3016788abf70de9b707f70">run</a> (int ndim, const std::vector&lt; size_t &gt; &amp;nobs, const std::vector&lt; const Float * &gt; &amp;batches, Float *output, const int *order=NULL)</td></tr>
<tr class="separator:a89af13dc9d3016788abf70de9b707f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010dfa065b986930ae6fb4abcb65fb56" id="r_a010dfa065b986930ae6fb4abcb65fb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html">Details</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a010dfa065b986930ae6fb4abcb65fb56">run</a> (int ndim, const std::vector&lt; size_t &gt; &amp;nobs, const Float *input, Float *output, const int *order=NULL)</td></tr>
<tr class="separator:a010dfa065b986930ae6fb4abcb65fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5919354983073576c83990400860b6b" id="r_ac5919354983073576c83990400860b6b"><td class="memTemplParams" colspan="2">template&lt;typename Batch &gt; </td></tr>
<tr class="memitem:ac5919354983073576c83990400860b6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html">Details</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmnncorrect_1_1MnnCorrect.html#ac5919354983073576c83990400860b6b">run</a> (int ndim, size_t nobs, const Float *input, const Batch *batch, Float *output, const int *order=NULL)</td></tr>
<tr class="separator:ac5919354983073576c83990400860b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Index = int, typename Float = double&gt;<br />
class mnncorrect::MnnCorrect&lt; Index, Float &gt;</div><p>Batch correction using mutual nearest neighbors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the data and distances.</td></tr>
  </table>
  </dd>
</dl>
<p>This class implements a variant of the MNN correction method described by Haghverdi <em>et al.</em> (2018). Two cells from different batches can form an MNN pair if they each belong in each other's set of nearest neighbors. The MNN pairs are assumed to represent cells from corresponding subpopulations across the two batches. Any differences in location between the paired cells can be interpreted as the batch effect and targeted for removal.</p>
<p>We consider one batch to be the "reference" and the other to be the "target", where the aim is to correct the latter to the (unchanged) former. For each observation in the target batch, we find the closest MNN pairs (based on the locations of the paired observation in the same batch) and we compute a robust average of the correction vectors involving those pairs. This average is used to obtain a single correction vector that is applied to the target observation to obtain corrected values.</p>
<p>Each MNN pair's correction vector is computed between the "center of mass" locations for the paired observations. The center of mass for each observation is defined as a robust average of a subset of neighboring observations from the same batch. Robustification is performed by iterations of trimming of observations that are furthest from the mean. In addition, we explicitly remove observations that are more than a certain distance from the observation in the MNN pair.</p>
<dl class="section see"><dt>See also</dt><dd>Haghverdi L et al. (2018). Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors. <em>Nature Biotech.</em> 36, 421-427 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a010dfa065b986930ae6fb4abcb65fb56" name="a010dfa065b986930ae6fb4abcb65fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010dfa065b986930ae6fb4abcb65fb56">&#9670;&#160;</a></span>run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html">Details</a> <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>nobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>order</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience overload to merge contiguous batches contained in the same array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nobs</td><td>Vector of length equal to the number of batches. Each entry contains the number of observations in each batch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to a column-major dimension-by-observation array containing the uncorrected data for all batches. Observations from the same batch are assumed to be contiguous, i.e., the first <code>nobs[0]</code> columns contain observations from the first batch, the next <code>nobs[1]</code> columns contain observations for the second batch, and so on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length equal to the product of <code>ndim</code> with the sum of <code>nobs</code>. This is used to store the corrected values from all batches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Pointer to an array of indices specifying the merge order. For example, the first entry contains the index of the batch in <code>nobs</code> to be used as the reference, the second entry specifies the batch to be merged first, and so on. All entries should be unique and lie in $[0, N)$ where $N$ is the number of batches. If omitted, the setting of <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html#abccae2e465b96ba5479e7413091b216b">set_automatic_order()</a></code> is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>output</code> is filled contiguously with the corrected values from successive batches. A <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html" title="Correction details.">Details</a></code> object is returned containing statistics about the merge process. </dd></dl>

</div>
</div>
<a id="a89af13dc9d3016788abf70de9b707f70" name="a89af13dc9d3016788abf70de9b707f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89af13dc9d3016788abf70de9b707f70">&#9670;&#160;</a></span>run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html">Details</a> <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>nobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Float * &gt; &amp;&#160;</td>
          <td class="paramname"><em>batches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>order</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge batches contained in separate arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nobs</td><td>Vector of length equal to the number of batches. Each entry contains the number of observations in each batch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>Vector of length equal to the number of batches. Each entry points to a column-major dimension-by-observation array containing the uncorrected data for each batch. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length equal to the product of <code>ndim</code> with the sum of <code>nobs</code>. This is used to store the corrected values from all batches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Pointer to an array of indices specifying the merge order. For example, the first entry contains the index of the batch in <code>batches</code> to be used as the reference, the second entry specifies the batch to be merged first, and so on. All entries should be unique and lie in $[0, N)$ where $N$ is the number of batches. If omitted, the setting of <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html#abccae2e465b96ba5479e7413091b216b">set_automatic_order()</a></code> is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>output</code> is filled contiguously with the corrected values from successive batches, i.e., the first batch takes <code>nobs[0] * ndim</code> elements, the second batch takes the next <code>nobs[1] * ndim</code> elements and so on. Filling is done column-major, i.e., values for the same observations are adjacent. A <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html" title="Correction details.">Details</a></code> object is returned containing statistics about the merge process. </dd></dl>

</div>
</div>
<a id="ac5919354983073576c83990400860b6b" name="ac5919354983073576c83990400860b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5919354983073576c83990400860b6b">&#9670;&#160;</a></span>run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<div class="memtemplate">
template&lt;typename Batch &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html">Details</a> <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Batch *&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>order</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge batches where observations are arbitrarily ordered in the same array.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Batch</td><td>Integer type for the batch IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nobs</td><td>Number of observations across all batches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to a column-major dimension-by-observation array containing the uncorrected data for all batches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch</td><td>Pointer to an array of length <code>nobs</code> containing the batch ID for each observation. IDs should be zero-indexed and lie within $[0, N)$ where $N$ is the number of unique batches. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length equal to the product of <code>ndim</code> with the sum of <code>nobs</code>. This is used to store the corrected values from all batches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Pointer to an array specifying the merge order. Entries should correspond to levels of <code>batch</code>; the first entry specifies the batch to use as the reference, the second entry specifies the first batch to merge, and so on. All entries should be unique and lie in $[0, N)$ where $N$ is the number of batches. If omitted, the setting of <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html#abccae2e465b96ba5479e7413091b216b">set_automatic_order()</a></code> is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>output</code> is filled with the corrected values from successive batches. The order of observations in <code>output</code> is the same as that in the <code>input</code> (i.e., not necessarily contiguous). A <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Details.html" title="Correction details.">Details</a></code> object is returned containing statistics about the merge process. </dd></dl>

</div>
</div>
<a id="abac16720074016f87dce57e6e02d6783" name="abac16720074016f87dce57e6e02d6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac16720074016f87dce57e6e02d6783">&#9670;&#160;</a></span>set_approximate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_approximate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#af5ce8974cee505b0bee5508a949cffba">Defaults::approximate</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Should an approximate nearest neighbor search be performed with Annoy?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object. </dd></dl>

</div>
</div>
<a id="abccae2e465b96ba5479e7413091b216b" name="abccae2e465b96ba5479e7413091b216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccae2e465b96ba5479e7413091b216b">&#9670;&#160;</a></span>set_automatic_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_automatic_order </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#aa3085207c438ba9757a792254ff1b19d">Defaults::automatic_order</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Should batches be ordered automatically?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object.</dd></dl>
<p>If <code>true</code> and <code>order</code> is not supplied in <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html#a89af13dc9d3016788abf70de9b707f70">run()</a></code>, the largest batch is used as the reference and other batches are successively merged onto it. At each merge step, we choose the batch that forms the largest number of MNNs with the current reference, and the merged dataset is defined as the new reference.</p>
<p>If <code>false</code> and <code>order</code> is not supplied, the supplied order of batches (or order of batch IDs) is used directly.</p>
<p>If <code>order</code> is supplied, this setting is ignored and the specified order is always used. </p>

</div>
</div>
<a id="af325d93c5f76c448d3cb79622aa558d3" name="af325d93c5f76c448d3cb79622aa558d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af325d93c5f76c448d3cb79622aa558d3">&#9670;&#160;</a></span>set_mass_cap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_mass_cap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a179d9c58273e3cce896b88b3e3bb78a6">Defaults::mass_cap</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Cap on the number of observations used to compute the center of mass for each MNN-involved observation. The dataset is effectively downsampled to <code>c</code> observations for this calculation, which improves speed at the cost of some precision.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object. </dd></dl>

</div>
</div>
<a id="a718ef3445e338d9a4694f06069cdbcf5" name="a718ef3445e338d9a4694f06069cdbcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718ef3445e338d9a4694f06069cdbcf5">&#9670;&#160;</a></span>set_num_mads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_num_mads </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a8638f5341f05f82e311284c6d3272e97">Defaults::num_mads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of median absolute deviations to use to define the distance threshold for the center of mass calculations. Larger values reduce biases from the kissing effect but increase the risk of including inappropriately distant subpopulations into the center of mass.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object. </dd></dl>

</div>
</div>
<a id="a9f1bb13e1d3b24607fa5d40763d1533c" name="a9f1bb13e1d3b24607fa5d40763d1533c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1bb13e1d3b24607fa5d40763d1533c">&#9670;&#160;</a></span>set_num_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_num_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a1ef386edadff91de8bf5a76590012b62">Defaults::num_neighbors</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nearest neighbors to use for the searches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object.</dd></dl>
<p>This parameter is used to define the MNN pairs at the start. Larger values increase the number of MNN pairs and improve the stability of the correction, at the cost of reduced resolution of matching subpopulations across batches. The number of neighbors is also used to identify the closest MNN pairs when computing the average correction vector for each target observation. Again, this improves stability at the cost of resolution for local variations in the correction vectors. </p>

</div>
</div>
<a id="a94ca84f936ea36ca7a47cfe73530be87" name="a94ca84f936ea36ca7a47cfe73530be87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ca84f936ea36ca7a47cfe73530be87">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#ae065e7d42f366755d4efc2b6d34b0a84">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object.</dd></dl>
<p>By default, <b>mnncorrect</b> uses OpenMP to implement parallelization. However, the <code>MNNCORRECT_CUSTOM_PARALLEL</code> macro can be set to a function that specifies a custom parallelization scheme. This function should be a template that accept three arguments:</p>
<ul>
<li><code>njobs</code>, an integer specifying the number of jobs.</li>
<li><code>fun</code>, a lambda that accepts two arguments, <code>start</code> and <code>end</code>.</li>
<li><code>nthreads</code>, an integer specifying the number of threads to use.</li>
</ul>
<p>The function should split <code>[0, njobs)</code> into any number of contiguous, non-overlapping intervals, and call <code>fun</code> on each interval, possibly in different threads. The details of the splitting and evaluation are left to the discretion of the developer defining the macro. The function should only return once all evaluations of <code>fun</code> are complete. </p>

</div>
</div>
<a id="a57469c9dfa55405b48d95adaadc08b5f" name="a57469c9dfa55405b48d95adaadc08b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57469c9dfa55405b48d95adaadc08b5f">&#9670;&#160;</a></span>set_reference_policy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_reference_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ReferencePolicy_8hpp.html#ad6c4a54a9f9a0db1d5863fc99fb6af47">ReferencePolicy</a>&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#afd120f73180d0caa12be40c6cb228841">Defaults::reference_policy</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The policy to use to choose the reference batch when <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html#abccae2e465b96ba5479e7413091b216b">set_automatic_order()</a></code> is <code>true</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object.</dd></dl>
<p>This setting only has an effect when an automatic merge order is used. See the <code>ReferencePolicy</code> documentation for more details on the available choices. </p>

</div>
</div>
<a id="a06edf42b962df693d51ef5d986141735" name="a06edf42b962df693d51ef5d986141735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06edf42b962df693d51ef5d986141735">&#9670;&#160;</a></span>set_robust_iterations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_robust_iterations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#a4ee36aa3844aa13ec6f627e80899fedc">Defaults::robust_iterations</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Number of iterations to use for robustification. At each iteration, the observations furthest from the mean are removed, and the mean is recomputed with the remaining observations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object. </dd></dl>

</div>
</div>
<a id="a866645cfd68a249ad550f73f7b87b67d" name="a866645cfd68a249ad550f73f7b87b67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866645cfd68a249ad550f73f7b87b67d">&#9670;&#160;</a></span>set_robust_trim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmnncorrect_1_1MnnCorrect.html">MnnCorrect</a> &amp; <a class="el" href="classmnncorrect_1_1MnnCorrect.html">mnncorrect::MnnCorrect</a>&lt; Index, Float &gt;::set_robust_trim </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structmnncorrect_1_1MnnCorrect_1_1Defaults.html#ac776c7e34a88f4cef47c6ce53c936fba">Defaults::robust_trim</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Trimming proportion to use for robustification when computing the center of mass. The <code>t</code> proportion of observations with the largest distances from the mean vector are removed for the next iteration of the mean calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classmnncorrect_1_1MnnCorrect.html" title="Batch correction using mutual nearest neighbors.">MnnCorrect</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>mnncorrect/<a class="el" href="MnnCorrect_8hpp_source.html">MnnCorrect.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
