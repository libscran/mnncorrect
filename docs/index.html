<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mnncorrect: C++ library for MNN correction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mnncorrect
   </div>
   <div id="projectbrief">Batch correction with mutual nearest neighbors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">C++ library for MNN correction </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2README"></a></p>
<p><img src="https://github.com/libscran/mnncorrect/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/libscran/mnncorrect/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/> <img src="https://github.com/libscran/mnncorrect/actions/workflows/compare-R.yaml/badge.svg" alt="R comparison" style="pointer-events: none;" class="inline"/> <a href="https://codecov.io/gh/libscran/mnncorrect"><img src="https://codecov.io/gh/libscran/mnncorrect/branch/master/graph/badge.svg?token=J3dxS3MtT1" alt="codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1>Overview</h1>
<p>This library performs unsupervised batch correction of high-dimensional data via the use of mutual nearest neighbors (MNNs). MNN correction was initially described in the context of single-cell RNA sequencing data analysis (see <a href="https://doi.org/10.1038/nbt.4091">Haghverdi et al., 2018</a>) but the same methodology can be applied for any high-dimensional data containing shared populations across multiple batches. The MNN implementation here is based on the <code>fastMNN()</code> function in the <a href="https://bioconductor.org/packages/batchelor"><b>batchelor</b> package</a>, which provides a number of improvements and speed-ups over the original method in the Haghverdi paper.</p>
<h1>Quick start</h1>
<p>Consider a dense matrix in column-major format where rows are dimensions (e.g., principal components) and cells are columns, and a vector of integers specifying the batch of origin for each cell. These are supplied to the <code><a class="el" href="namespacemnncorrect.html#a0ce88c6787f0f2ec73101fc234589ee6">mnncorrect::compute()</a></code> function to compute corrected values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mnncorrect/MnnCorrect.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;double&gt; matrix(ndim * nobs); <span class="comment">// fill with values...</span></div>
<div class="line">std::vector&lt;int&gt; batch(nobs) <span class="comment">// fill with batch IDs from [0, num_batches)</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structmnncorrect_1_1Options.html">mnncorrect::Options&lt;int, double&gt;</a> opt;</div>
<div class="line">std::vector&lt;double&gt; output(ndim * nobs);</div>
<div class="line"><a class="code hl_function" href="namespacemnncorrect.html#a0ce88c6787f0f2ec73101fc234589ee6">mnncorrect::compute</a>(ndim, nobs, matrix.data(), batch.data(), output.data(), opt);</div>
<div class="ttc" id="anamespacemnncorrect_html_a0ce88c6787f0f2ec73101fc234589ee6"><div class="ttname"><a href="namespacemnncorrect.html#a0ce88c6787f0f2ec73101fc234589ee6">mnncorrect::compute</a></div><div class="ttdeci">void compute(std::size_t num_dim, const std::vector&lt; Index_ &gt; &amp;num_obs, const std::vector&lt; const Float_ * &gt; &amp;batches, Float_ *output, const Options&lt; Index_, Float_, Matrix_ &gt; &amp;options)</div><div class="ttdef"><b>Definition</b> mnncorrect.hpp:142</div></div>
<div class="ttc" id="astructmnncorrect_1_1Options_html"><div class="ttname"><a href="structmnncorrect_1_1Options.html">mnncorrect::Options</a></div><div class="ttdoc">Options for compute().</div><div class="ttdef"><b>Definition</b> mnncorrect.hpp:36</div></div>
</div><!-- fragment --><p>We also support batches in separate arrays, storing the corrected values for all batches in a single output array:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> nbatches = 3;</div>
<div class="line">std::vector&lt;int&gt; batch_size;</div>
<div class="line">std::vector&lt;std::vector&lt;double&gt; &gt; batches;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> b = 0; b &lt; 3; ++b) { <span class="comment">// mocking up three batches of different size.</span></div>
<div class="line">    batch_size.push_back((b + 1) * 100);</div>
<div class="line">    batch.resize(ndim * batch_size.back()); <span class="comment">// fill with values...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::size_t total_size = std::accumulate(batch_size.begin(), batch_size.end(), 0);</div>
<div class="line">std::vector&lt;double&gt; output(ndim * total_size);</div>
<div class="line"><a class="code hl_function" href="namespacemnncorrect.html#a0ce88c6787f0f2ec73101fc234589ee6">mnncorrect::compute</a>(ndim, batch_size, batch_ptrs, output.data(), opt);</div>
</div><!-- fragment --><p>Advanced users can also fiddle with the options:</p>
<div class="fragment"><div class="line"><span class="comment">// Number of neighbors to use for MNN identification.</span></div>
<div class="line">opt.num_neighbors = 10;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parallelization of various calculations, e.g., neighbor search.</span></div>
<div class="line">opt.num_threads = 3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Number of recursive steps for calculation of the center of mass.</span></div>
<div class="line">opt.num_steps = 2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Change the nearest-neighbor search algorithm:</span></div>
<div class="line">opt.builder.reset(<span class="keyword">new</span> knncolle_annoy::AnnoyBuilder&lt;Annoy::Euclidean&gt;);</div>
</div><!-- fragment --><p>See the <a href="https://libscran.github.io/mnncorrect">reference documentation</a> for more details.</p>
<h1>Theoretical details</h1>
<p>We assume that (i) our batches share some subpopulations, and (ii) even after the addition of an arbitrary batch effect, the cells from one subpopulation in one batch are still closer to the cells in the corresponding subpopulation in the other batch (and vice versa) when compared to cells in different subpopulations. Thus, by identifying pairs of cells that are MNNs, we can determine which subpopulations are shared across batches. Any differences in location between batches for the shared subpopulations are attributed to batch effects and targeted for removal. In contrast, a subpopulation unique to a single batch will not contain any MNNs (and thus will not interfere with correction), as it will not have a corresponding subpopulation in the other batch for which it can be the closest neighbor.</p>
<p>To remove batch effects, we consider one batch to be the "reference" and another to be the "target". For each MNN pair, we compute a correction vector that moves the target batch towards the reference. For each cell $i$ in the target batch, we identify the closest cell in the same batch that is part of a MNN pair (i.e., "MNN-involved cells") and apply the pair's correction vector to $i$'s coordinates. The use of the closest MNN-involved cell allows the correction to adjust to local variations in the magnitude and direction of the batch effect. If an MNN-involved cell in the target batch is part of multiple MNN pairs, we only use the correction vector of the pair with the shortest distance between its paired cells, for simplicity.</p>
<p>The correction vector for each MNN pair is not directly computed from its two paired cells. Rather, for each cell, we compute a "center of mass" using neighboring points from the same batch. Most simply, the center of mass is defined as the mean coordinates of the $k$ nearest neighbors of each MNN-involved cell. This can be done recursively with the neighbors of those neighbors, etc., up to a user-specified recursion depth. The aim is to eliminate "kissing" effects where the correction only brings the surfaces of the batches into contact.</p>
<p>In the case of &gt;2 batches, we define a merge order based on the batch size, variance, residual sum of squares, or the input order. For the first batch to be merged, we identify MNN pairs to all other batches at once. The subsequent correction effectively distributes the first batch's cells to all other batches. This process is repeated for all remaining batches until only one batch remains that contains all cells. By using all batches to identify MNN pairs at each step, we improve the chance of correctly matching subpopulations across batches, even if they are missing from certain batches.</p>
<h1>Examples</h1>
<p>The <code>tests/R/examples</code> directory contains a few examples using the C++ code on some real datasets (namely, single-cell RNA-seq datasets). To run these, install the package at <code>tests/R/package</code> (this requires the <a href="https://github.com/LTLA/scran.chan"><b>scran.chan</b></a> package, which also wraps this C++ library in a more complete package).</p>
<p><code>pbmc</code>: mergesthe PBMC 3K and 4K datasets from 10X Genomics. These are technical replicates (I think) so a complete merge is to be expected.</p>
<p><img src="https://raw.githubusercontent.com/libscran/mnncorrect/images/tests/R/examples/pbmc/output_simple.png" alt="pbmc-output" class="inline"/></p>
<p><code>pancreas</code>: merges the <a href="https://dx.doi.org/10.1016%2Fj.stem.2016.05.010">Grun et al. (2016)</a> and <a href="https://doi.org/10.1016/j.cels.2016.09.002">Muraro et al. (2016)</a> datasets. I believe this involves data from different patients but using the same-ish technology.</p>
<p><img src="https://raw.githubusercontent.com/libscran/mnncorrect/images/tests/R/examples/pancreas/output_simple.png" alt="pancreas-output" class="inline"/></p>
<p><code>neurons</code>: merges the <a href="https://doi.org/10.1126/science.aaa1934">Zeisel et al. (2015)</a> and <a href="https://doi.org/10.1038/nn.4216">Tasic et al. (2016)</a> datasets. This involves different technologies and different cell populations.</p>
<p><img src="https://raw.githubusercontent.com/libscran/mnncorrect/images/tests/R/examples/neurons/output_simple.png" alt="neurons-output" class="inline"/></p>
<h1>Building projects</h1>
<h2>CMake with <code>FetchContent</code></h2>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  mnncorrect</div>
<div class="line">  GIT_REPOSITORY https://github.com/libscran/mnncorrect</div>
<div class="line">  GIT_TAG master # replace with a pinned release</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(mnncorrect)</div>
</div><!-- fragment --><p>Then you can link to <b>libscran</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe mnncorrect)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE mnncorrect)</div>
</div><!-- fragment --><p>By default, this will use <code>FetchContent</code> to fetch all external dependencies. Applications should consider pinning versions of dependencies for stability - see <a href="extern/CMakeLists.txt"><code>extern/CMakeLists.txt</code></a> for suggested versions. If you want to install them manually, use <code>-DMNNCORRECT_FETCH_EXTERN=OFF</code>.</p>
<h2>CMake with <code>find_package()</code></h2>
<div class="fragment"><div class="line">find_package(libscran_mnncorrect CONFIG REQUIRED)</div>
<div class="line">target_link_libraries(mylib INTERFACE libscran::mnncorrect)</div>
</div><!-- fragment --><p>To install the library, use:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DMNNCORRECT_TESTS=OFF</div>
<div class="line">cmake --build . --target install</div>
</div><!-- fragment --><p>Again, this will use <code>FetchContent</code> to retrieve dependencies, see comments above.</p>
<h2>Manual</h2>
<p>If you're not using CMake, the simple approach is to just copy the files - either directly or with Git submodules - and include their path during compilation with, e.g., GCC's <code>-I</code>. This also requires the external dependencies listed in <a href="extern/CMakeLists.txt"><code>extern/CMakeLists.txt</code></a>.</p>
<h1>References</h1>
<p>Haghverdi L, Lun ATL, Morgan MD, Marioni JC (2018). Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors. <em>Nat. Biotechnol.</em> 36(5):421-427 </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
